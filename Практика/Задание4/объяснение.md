Вот подробные комментарии к коду Erlang:

```erlang
% Определение модуля parallel_sum
-module(parallel_sum).
% Экспорт функции main/0, то есть она доступна для вызова извне.
-export([main/0]).

% Функция main/0, которая является точкой входа для программы
main() ->
    % Инициализация переменных для диапазона чисел и шага
    Start = 0,         % Начальное значение X
    End = 3.14,        % Конечное значение X (приблизительно пи)
    Step = 0.0000001,  % Шаг, с которым будет увеличиваться X (очень маленький)

    % Параллельный запуск двух потоков для первых двух функций
    % Параметры для функции: диапазон от Start до End, шаг Step, сама функция и родительский процесс (self()) для получения результата.
    Pid1 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X -> math:cos(X) + 45 * math:pow(X, 2) end), self() end),
    Pid2 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X -> 1 / (X + 1) end), self() end),

    % Получение результатов из первого потока (Pid1)
    receive
        {result, Sum1} -> 
            io:format("Сумма функции 1 (y = cos(x) + 45x^2): ~p~n", [Sum1])
    end,

    % Получение результатов из второго потока (Pid2)
    receive
        {result, Sum2} -> 
            io:format("Сумма функции 2 (y = 1 / (x + 1)): ~p~n", [Sum2])
    end,

    % Запуск третьего потока для функции y = 34x + 0.098
    Pid3 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X -> 34 * X + 0.098 end), self() end),

    % Получение результата из третьего потока (Pid3)
    receive
        {result, Sum3} -> 
            io:format("Сумма функции 3 (y = 34x + 0.098): ~p~n", [Sum3])
    end,

    % После получения результатов из всех потоков, вычисление среднего значения всех сумм
    Average = (Sum1 + Sum2 + Sum3) / 3,
    io:format("Среднее значение: ~p~n", [Average]).

% Функция calculate_sum/5, которая будет запускать вычисления в цикле для каждой функции
% Аргументы:
% - Start: начальное значение X
% - End: конечное значение X
% - Step: шаг изменения X
% - Fun: функция для вычислений
% - Parent: родительский процесс, которому нужно отправить результат
calculate_sum(Start, End, Step, Fun, Parent) ->
    % Вычисление суммы с использованием вспомогательной функции calculate_sum_loop
    Sum = calculate_sum_loop(Start, End, Step, Fun, 0),
    % Отправка результата в родительский процесс
    Parent ! {result, Sum}.

% Рекурсивная функция calculate_sum_loop/5 для вычисления суммы с использованием функции Fun
% Аргументы:
% - X: текущее значение X
% - End: конечное значение X
% - Step: шаг изменения X
% - Fun: функция для вычислений
% - Acc: аккумулятор для накопления суммы
calculate_sum_loop(X, End, Step, Fun, Acc) when X > End -> 
    % Когда X превышает End, рекурсия завершена, возвращаем накопленную сумму (Acc)
    Acc;
calculate_sum_loop(X, End, Step, Fun, Acc) -> 
    % Вычисление значения функции Fun для текущего X
    NewAcc = Acc + Fun(X),
    % Рекурсивный вызов функции для следующего X
    calculate_sum_loop(X + Step, End, Step, Fun, NewAcc).
```

### Подробное объяснение всех частей кода:

1. **Модуль и экспорт:**
  - В первой строке создается модуль `parallel_sum`, который является контейнером для функций. Этот модуль определяет несколько функций, включая `main/0`, которая будет вызвана при запуске программы.
  - Механизм `-export([main/0]).` делает функцию `main` доступной извне. Параметр `/0` указывает, что функция не принимает аргументов.

2. **Функция `main/0`:**
  - В этой функции задаются начальные параметры:
    - `Start` — начальное значение для переменной X (0).
    - `End` — конечное значение для X (3.14 — примерно π).
    - `Step` — шаг, с которым будет увеличиваться X (очень маленький шаг для точных вычислений).
  - Далее создаются три параллельных процесса с помощью функции `spawn`. Каждый процесс будет вычислять сумму для своей функции:
    - `Pid1` запускает процесс для функции `y = cos(x) + 45 * x^2`.
    - `Pid2` запускает процесс для функции `y = 1 / (x + 1)`.
    - `Pid3` запускает процесс для функции `y = 34 * x + 0.098`.
  - После этого идет блок `receive`, который ожидает получения результатов от этих потоков. Когда результат получен, он выводится с помощью функции `io:format/2`.
  - В конце вычисляется среднее значение всех сумм, полученных из потоков, и выводится на экран.

3. **Функция `calculate_sum/5`:**
  - Эта функция запускает вычисления для каждой из функций в отдельных потоках. Она принимает следующие параметры:
    - `Start` — начальное значение для X.
    - `End` — конечное значение для X.
    - `Step` — шаг для увеличения X.
    - `Fun` — это сама функция, которая будет применяться к каждому значению X.
    - `Parent` — это родительский процесс, которому будет отправлен результат вычислений.
  - Внутри этой функции вызывается вспомогательная рекурсивная функция `calculate_sum_loop/5`, которая выполняет итерации от `Start` до `End`, накапливая сумму.

4. **Рекурсивная функция `calculate_sum_loop/5`:**
  - Эта функция выполняет саму итерацию вычислений:
    - Когда значение `X` превышает `End`, функция возвращает накопленную сумму (значение в `Acc`).
    - Когда значение `X` не превышает `End`, она применяет функцию `Fun(X)`, добавляет результат к аккумулятору `Acc`, а затем вызывает себя с обновленным значением `X` и аккумулятором.
  - Функция будет продолжать вычисления, пока не достигнет значения `End`, после чего завершится.

### Типы данных:
- Все переменные, такие как `Start`, `End`, `Step`, имеют тип `float` (действительные числа), так как функции используют математические операции с числами с плавающей точкой.
- Результат работы функции — это тоже тип `float`, представляющий сумму значений, вычисленных для каждого X.
- `Pid1`, `Pid2`, и `Pid3` — это процессы (параллельные потоки), которые возвращают процессы идентификаторов.
- Сообщения между процессами имеют формат `{result, Sum}`, где `Sum` — это результат вычислений (тип `float`).

Таким образом, программа выполняет вычисления для нескольких математических функций в параллельных потоках, затем суммирует результаты и вычисляет их среднее значение.