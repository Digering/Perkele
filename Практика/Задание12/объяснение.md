Вот пример подробного комментарирования кода:

```java
package ip.ivanov.danil.Практика.Задание12;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.DoubleUnaryOperator;

public class ParallelFunctionSum {

    public static void main(String[] args) throws Exception {
        // Начало интервала для вычислений
        double start = 0.0;       // Переменная типа double, хранит начало интервала (начало отрезка для интеграции или суммирования)
        double end = 3.14;        // Переменная типа double, хранит конец интервала (конец отрезка для интеграции или суммирования)
        double step = 0.0000001;  // Переменная типа double, определяет шаг, с которым будем двигаться по интервалу. Очень маленький шаг для точных вычислений

        // Создаем пул потоков, который будет управлять 2 потоками (например, 2 ядра процессора)
        ExecutorService executor = Executors.newFixedThreadPool(2); // Пул потоков с размером 2, что означает, что максимум будет работать 2 потока одновременно

        // Первая группа задач (две функции, которые будем вычислять параллельно)
        // Используем метод submit, чтобы отправить задачи в пул потоков
        Future<Double> sum1 = executor.submit(() -> calculateSum(start, end, step, x -> Math.cos(x) + 45 * x * x));
        // В этой задаче мы вычисляем сумму функции cos(x) + 45 * x^2 на интервале от start до end с шагом step
        Future<Double> sum2 = executor.submit(() -> calculateSum(start, end, step, x -> 1 / (x + 1)));
        // Здесь суммируем значения функции 1 / (x + 1) на том же интервале с тем же шагом

        // Ждем результата от первой группы потоков (каждый Future представляет собой задачу, выполняющуюся в другом потоке)
        double result1 = sum1.get(); // Получаем результат выполнения первой задачи (первую сумму)
        double result2 = sum2.get(); // Получаем результат выполнения второй задачи (вторую сумму)

        // Вторая группа задач
        // Вторая группа потоков, здесь тоже будем вычислять суммы для двух других функций
        Future<Double> sum3 = executor.submit(() -> calculateSum(start, end, step, x -> 34 * x + 0.098));
        // В этой задаче считаем сумму функции 34 * x + 0.098 на том же интервале
        Future<Double> sum4 = executor.submit(() -> calculateSum(start, end, step, x -> 17 * x + 9.8));
        // Здесь суммируем значения функции 17 * x + 9.8 на том же интервале

        // Ждем завершения второй группы задач и получаем результаты
        double result3 = sum3.get(); // Получаем результат от третьей задачи
        double result4 = sum4.get(); // Получаем результат от четвертой задачи

        // После завершения всех задач завершаем работу с пулом потоков
        executor.shutdown(); // Завершаем работу пула потоков, после чего нельзя будет отправлять новые задачи в этот пул

        // Вычисляем среднее значение всех сумм, которое будет отображать средний результат всех вычислений
        double average = (result1 + result2 + result3 + result4) / 4; // Считаем среднее арифметическое из всех 4-х сумм

        // Выводим результаты вычислений в консоль
        System.out.println("Sum 1 (cos(x) + 45x^2): " + result1); // Выводим первую сумму (результат для функции cos(x) + 45 * x^2)
        System.out.println("Sum 2 (1/(x+1)): " + result2); // Выводим вторую сумму (результат для функции 1 / (x + 1))
        System.out.println("Sum 3 (34x + 0.098): " + result3); // Выводим третью сумму (результат для функции 34 * x + 0.098)
        System.out.println("Sum 4 (17x + 9.8): " + result4); // Выводим четвертую сумму (результат для функции 17 * x + 9.8)
        System.out.println("Average of all sums: " + average); // Выводим среднее всех сумм
    }

    /**
     * Метод для вычисления суммы значений функции на заданном интервале.
     * Этот метод принимает начало и конец интервала, шаг, а также саму функцию для вычислений.
     * 
     * @param start Начало интервала (тип double)
     * @param end Конец интервала (тип double)
     * @param step Шаг, с которым будем двигаться по интервалу (тип double)
     * @param function Функция, которую будем интегрировать или суммировать (тип DoubleUnaryOperator)
     * 
     * @return Сумма значений функции на заданном интервале (тип double)
     */
    private static double calculateSum(double start, double end, double step, DoubleUnaryOperator function) {
        double sum = 0.0; // Переменная для хранения суммы значений функции
        // Цикл от start до end с шагом step
        for (double x = start; x <= end; x += step) {
            // Для каждого значения x применяем функцию и добавляем результат к общей сумме
            sum += function.applyAsDouble(x);
        }
        return sum; // Возвращаем сумму значений функции
    }
}
```

### Объяснение кода:

1. **Основной класс и методы**:
    - В классе `ParallelFunctionSum` используется пул потоков для параллельных вычислений. Мы используем пул из двух потоков для вычисления четырех сумм (каждая из которых является интегралом или суммой функции на интервале).

2. **Метод `main`**:
    - Мы определяем три переменные (`start`, `end`, `step`), которые задают границы интервала и шаг для суммирования. Это необходимо для вычисления сумм значений функции по методу численного интегрирования.
    - Далее, с использованием `ExecutorService` создается пул потоков, в который отправляются задачи (функции для суммирования).
    - Каждая задача реализована с помощью лямбда-выражений. Каждое лямбда-выражение передает в метод `calculateSum` функцию для вычислений.
    - После того как все задачи выполняются, результаты из `Future` объектов извлекаются с помощью метода `get()`, и выводятся в консоль.
    - Рассчитывается среднее всех четырех сумм.

3. **Метод `calculateSum`**:
    - Этот метод принимает параметры: начало и конец интервала, шаг и функцию для вычислений. Функция передается как `DoubleUnaryOperator` — это функциональный интерфейс, представляющий операцию над одним значением типа `double`.
    - Внутри метода мы используем цикл `for`, который шаг за шагом вычисляет значения функции и добавляет их к общей сумме.
    - По завершении цикла возвращается сумма всех вычисленных значений.

### Типы данных:
- **double**: используется для хранения числовых значений (например, границы интервала и результаты вычислений).
- **ExecutorService**: интерфейс, который управляет пулом потоков для параллельных вычислений.
- **Future**: объект, который представляет собой результат асинхронной операции, то есть задачи, выполненной в другом потоке.
- **DoubleUnaryOperator**: функциональный интерфейс, который представляет функцию, принимающую и возвращающую `double` значение.

### Параллельное выполнение:
- Используя пул потоков, программа может выполнять несколько вычислений одновременно, что ускоряет процесс обработки, особенно при больших объемах данных или сложных вычислениях.