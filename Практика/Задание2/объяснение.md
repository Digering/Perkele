Конечно! Вот код с подробными комментариями, поясняющими каждый момент:

```java
// Пакеты, которые мы будем использовать
import java.util.concurrent.*;  // Для работы с многозадачностью (ExecutorService, Callable, Future)
import java.util.function.Function;  // Для использования функциональных интерфейсов, например, для передачи функций как параметров

// Основной класс
public class ParallelSum {

    // Константы, определяющие параметры вычислений
    private static final double START = 0;  // Начало интервала для вычислений (0)
    private static final double END = 3.14;  // Конец интервала для вычислений (примерно Пи, 3.14)
    private static final double STEP = 0.0000001;  // Шаг, с которым будет вычисляться функция (очень маленький для высокой точности)

    // Главный метод, с которого начинается выполнение программы
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // Создаем пул потоков с фиксированным количеством потоков (2 потока)
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачи для параллельного вычисления:
        // Задача 1 - вычисление суммы значений функции cos(x) + 45 * x^2
        // Используем лямбда-выражение, которое описывает функцию
        Callable<Double> task1 = () -> calculateSum(START, END, STEP, x -> Math.cos(x) + 45 * Math.pow(x, 2));
        
        // Задача 2 - вычисление суммы значений функции 1 / (x + 1)
        Callable<Double> task2 = () -> calculateSum(START, END, STEP, x -> 1 / (x + 1));

        // Запускаем задачи в пуле потоков и получаем объекты Future для получения результатов
        Future<Double> result1 = executor.submit(task1);  // Задача 1
        Future<Double> result2 = executor.submit(task2);  // Задача 2

        // Получаем результаты выполнения задач с помощью метода get(). 
        // Метод get() блокирует выполнение, пока задача не завершится и результат не будет готов.
        double sum1 = result1.get();  // Получаем результат вычислений для первой функции
        double sum2 = result2.get();  // Получаем результат вычислений для второй функции

        // Закрытие пула потоков после выполнения всех задач
        executor.shutdown();  // Закрытие пула потоков, чтобы освободить ресурсы

        // Вычисление третьей функции в основном потоке (не параллельно)
        // Функция 3: y = 34x + 0.098
        double sum3 = calculateSum(START, END, STEP, x -> 34 * x + 0.098);

        // Вычисляем среднее значение суммы всех трех функций
        double average = (sum1 + sum2 + sum3) / 3;

        // Выводим результаты на экран
        System.out.println("Сумма функции 1 (y = cos(x) + 45x^2): " + sum1);
        System.out.println("Сумма функции 2 (y = 1 / (x + 1)): " + sum2);
        System.out.println("Сумма функции 3 (y = 34x + 0.098): " + sum3);
        System.out.println("Среднее значение: " + average);
    }

    // Метод для вычисления суммы значений функции на заданном интервале с шагом
    // Принимает параметры:
    // - start (начало интервала),
    // - end (конец интервала),
    // - step (шаг для вычислений),
    // - function (функция, которую будем вычислять, представлена интерфейсом Function)
    private static double calculateSum(double start, double end, double step, Function<Double, Double> function) {
        double sum = 0;  // Переменная для хранения суммы значений функции

        // Проходим по всему интервалу от start до end с шагом step
        for (double x = start; x <= end; x += step) {
            sum += function.apply(x);  // Для каждого x вычисляем значение функции и прибавляем к сумме
        }

        // Возвращаем итоговую сумму
        return sum;
    }
}
```

### Подробное объяснение каждого элемента:

---

#### Пакеты:

```java
import java.util.concurrent.*;
import java.util.function.Function;
```

- **`java.util.concurrent`** — пакет, предоставляющий функциональность для работы с многозадачностью:
    - **`ExecutorService`** — интерфейс для управления пулом потоков.
    - **`Callable`** — интерфейс для задач, которые могут возвращать результат.
    - **`Future`** — представляет результат, который будет вычислен в будущем (позволяет ожидать результат выполнения задачи).
- **`java.util.function.Function`** — функциональный интерфейс, который принимает один аргумент и возвращает результат. В данном случае используется для передачи математических функций, которые нужно вычислить на интервале.

---

#### Константы:
```java
private static final double START = 0;  
private static final double END = 3.14;  
private static final double STEP = 0.0000001;  
```

- **`START`** — начальная точка интервала для вычислений. Задаем как 0.
- **`END`** — конечная точка интервала для вычислений. Задаем как приближенное значение π (3.14).
- **`STEP`** — шаг между вычислениями. Установлен очень малым, чтобы получить высокую точность (точность зависит от этого значения).

---

#### Главный метод:

```java
public static void main(String[] args) throws InterruptedException, ExecutionException {
```

- **`throws InterruptedException, ExecutionException`** — эти исключения могут быть выброшены, если задачи в пуле потоков были прерваны или завершились с ошибкой. Они обрабатываются в блоке `main`.

---

#### Создание пула потоков:

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
```

- **`ExecutorService executor`** — объект, управляющий пулом потоков. Он будет использовать два потока для параллельной работы.
- **`Executors.newFixedThreadPool(2)`** — создает пул потоков с фиксированным количеством потоков (в данном случае 2).

---

#### Определение задач для параллельных вычислений:

```java
Callable<Double> task1 = () -> calculateSum(START, END, STEP, x -> Math.cos(x) + 45 * Math.pow(x, 2));
Callable<Double> task2 = () -> calculateSum(START, END, STEP, x -> 1 / (x + 1));
```

- **`Callable<Double>`** — это функциональный интерфейс, который представляет задачу, возвращающую результат типа `Double`.
- Лямбда-выражения описывают функции, которые будем вычислять на интервале от `START` до `END`:
    - Для **`task1`** — вычисление функции `cos(x) + 45 * x^2`.
    - Для **`task2`** — вычисление функции `1 / (x + 1)`.

---

#### Запуск задач в пуле потоков:

```java
Future<Double> result1 = executor.submit(task1);
Future<Double> result2 = executor.submit(task2);
```

- **`submit()`** — метод, который отправляет задачу на выполнение в пул потоков.
- **`Future<Double> result1`** и **`result2`** — объекты, которые будут хранить результаты выполнения задач. Мы можем использовать `get()` для получения результата, блокируя выполнение до завершения задачи.

---

#### Получение результатов задач:

```java
double sum1 = result1.get();
double sum2 = result2.get();
```

- **`get()`** — метод, который блокирует выполнение до тех пор, пока задача не завершится, и возвращает результат выполнения задачи.

---

#### Закрытие пула потоков:

```java
executor.shutdown();
```

- **`shutdown()`** — завершает работу пула потоков и освобождает ресурсы.

---

#### Вычисление третьей функции:

```java
double sum3 = calculateSum(START, END, STEP, x -> 34 * x + 0.098);
```

- Для вычисления функции `34x + 0.098` используется метод `calculateSum`, который выполняет вычисления в основном потоке (не параллельно).

---

#### Вычисление среднего значения:

```java
double average = (sum1 + sum2 + sum3) / 3;
```

- После получения сумм для всех трех функций, вычисляем их среднее значение.

---

#### Вывод результатов:

```java
System.out.println("Сумма функции 1 (y = cos(x) + 45x^2): " + sum1);
System.out.println("Сумма функции 2 (y = 1 / (x + 1)): " + sum2);
System.out.println("Сумма функции 3 (y = 34x + 0.098): " + sum3);
System.out.println("Среднее значение: " + average);
```

- Выводим результаты на экран для каждой функции и среднего значения.

---

#### Метод для вычисления суммы:

```java
private static double calculateSum(double start, double end, double step, Function<Double, Double> function) {
    double sum = 0;
    for (double x = start; x <= end; x += step) {
        sum += function.apply(x);
    }
    return sum;
}
```

- **`calculateSum`** — метод, который вычисляет сумму значений функции на заданном интервале.
- Принимает параметры:
    - `start` — начало интервала.
    - `end` — конец интервала.
    - `step` — шаг для вычислений.
    - `function` — функция, которую мы будем вычислять для каждого значения `x` на интервале.
- **`function.apply(x)`** — применяет функцию к значению `x` для вычисления значения функции.

---

### Подведение итогов:

- **Типы данных**:
    - `double` — используется для всех числовых вычислений с плавающей запятой.
    - `Callable<Double>` — интерфейс для задач, возвращающих результат типа `Double`.
    -

`Future<Double>` — для получения результатов выполнения параллельных задач.

- **Основной поток и параллельные вычисления**:
    - Параллельные вычисления выполняются в пуле из двух потоков с использованием `ExecutorService` и `Callable`.
    - Основной поток вычисляет третью функцию по завершению параллельных вычислений.