Вот ваш код с подробными комментариями, объясняющими каждый его элемент, функции, типы данных и логику:

```erlang
% Определение модуля parallel_sum
-module(parallel_sum).
% Экспорт функции main, чтобы она была доступна для вызова из других мест
-export([main/0]).

% Основная функция main/0
main() ->
    % Начальная и конечная границы диапазона для суммирования (x от 0 до 6.28)
    Start = 0,
    End = 6.28,
    % Шаг для итераций
    Step = 0.0000001,

    % Запуск первого потока для функции y = 34x + 0.098
    % spawn создает новый процесс, который выполняет функцию calculate_sum.
    % self() передает идентификатор текущего процесса в качестве получателя результатов.
    Pid1 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> 34 * X + 0.098 end, self()) end),

    % Получение результата из первого потока через сообщение.
    % receive ожидает получение сообщения в виде {result, Sum1}.
    receive
        {result, Sum1} -> 
            % Выводим результат суммы для первой функции
            io:format("Сумма функции 1 (y = 34x + 0.098): ~p~n", [Sum1])
    end,

    % Параллельный запуск двух потоков для оставшихся функций.
    % Первый поток выполняет функцию y = sin(x) + 45x^2
    Pid2 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> math:sin(X) + 45 * math:pow(X, 2) end, self()) end),
    % Второй поток выполняет функцию y = 1 / (x + 1)
    Pid3 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> 1 / (X + 1) end, self()) end),

    % Получение результатов из двух потоков
    % Ожидаем результаты от второго потока
    receive
        {result, Sum2} -> 
            % Выводим результат суммы для второй функции
            io:format("Сумма функции 2 (y = sin(x) + 45x^2): ~p~n", [Sum2])
    end,
    % Ожидаем результаты от третьего потока
    receive
        {result, Sum3} -> 
            % Выводим результат суммы для третьей функции
            io:format("Сумма функции 3 (y = 1 / (x + 1)): ~p~n", [Sum3])
    end,

    % Вычисление среднего значения суммы для всех трех функций
    Average = (Sum1 + Sum2 + Sum3) / 3,
    % Выводим среднее значение
    io:format("Среднее значение: ~p~n", [Average]).

% Функция для вычисления суммы значений функции на интервале [Start, End]
% Включает в себя вызов вспомогательной функции calculate_sum_loop для вычислений.
calculate_sum(Start, End, Step, Fun, Parent) ->
    % Запуск рекурсивного вычисления суммы с начальным значением аккумулятора 0
    Sum = calculate_sum_loop(Start, End, Step, Fun, 0),
    % Отправка результата обратно в родительский процесс (Parent)
    Parent ! {result, Sum}.

% Рекурсивная вспомогательная функция для вычисления суммы.
% Принимает текущую позицию X, конец диапазона End, шаг Step, функцию Fun и аккумулятор Acc.
calculate_sum_loop(X, End, Step, Fun, Acc) when X > End -> 
    % Базовое условие: если X превышает End, возвращаем аккумулятор как результат.
    Acc;
calculate_sum_loop(X, End, Step, Fun, Acc) -> 
    % Иначе вычисляем значение функции Fun(X) и добавляем его к аккумулятору
    NewAcc = Acc + Fun(X),
    % Рекурсивно вызываем функцию для следующего значения X
    calculate_sum_loop(X + Step, End, Step, Fun, NewAcc).
```

### Подробное объяснение:

#### Модуль и экспорт
```erlang
-module(parallel_sum).
-export([main/0]).
```
- **`-module(parallel_sum).`** — определяет имя модуля (файла). Все функции, определенные в этом модуле, будут доступны для использования после компиляции модуля с этим именем.
- **`-export([main/0]).`** — экспортирует функцию `main/0`, что делает её доступной для вызова извне.

#### Основная функция `main/0`
```erlang
main() ->
    Start = 0,
    End = 6.28,
    Step = 0.0000001,
```
- Здесь задаются параметры для вычислений. `Start` и `End` — это начало и конец диапазона для суммирования, а `Step` — это маленький шаг для изменения значения X на каждом шаге.

#### Запуск первого потока
```erlang
Pid1 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> 34 * X + 0.098 end, self()) end),
```
- **`spawn/1`** — создает новый процесс (поток), который выполнит переданную функцию. В данном случае, это вызов `calculate_sum/5`, который выполняется в новом потоке.
- **`fun(X) -> 34 * X + 0.098 end`** — это анонимная функция, которая вычисляет значение функции `y = 34x + 0.098` для переданного X.
- **`self()`** — передает идентификатор текущего процесса в качестве получателя для получения результатов вычислений из потока. После того как поток завершится свою работу, он отправит результат обратно в этот процесс.

#### Получение результатов
```erlang
receive
    {result, Sum1} -> 
        io:format("Сумма функции 1 (y = 34x + 0.098): ~p~n", [Sum1])
end,
```
- **`receive`** — ожидает получения сообщения. В данном случае, процесс будет ожидать получения сообщения с результатом вычислений `{result, Sum1}`.
- **`io:format/2`** — выводит сообщение в консоль с отформатированным результатом.

#### Запуск двух других потоков
```erlang
Pid2 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> math:sin(X) + 45 * math:pow(X, 2) end, self()) end),
Pid3 = spawn(fun() -> calculate_sum(Start, End, Step, fun(X) -> 1 / (X + 1) end, self()) end),
```
- Здесь создаются два дополнительных потока для вычисления сумм для двух других функций:
    - `y = sin(x) + 45x^2` в первом потоке.
    - `y = 1 / (x + 1)` во втором потоке.

#### Получение результатов из двух потоков
```erlang
receive
    {result, Sum2} -> 
        io:format("Сумма функции 2 (y = sin(x) + 45x^2): ~p~n", [Sum2])
end,
receive
    {result, Sum3} -> 
        io:format("Сумма функции 3 (y = 1 / (x + 1)): ~p~n", [Sum3])
end,
```
- Каждое `receive` ожидает результат из соответствующего потока и выводит его.

#### Вычисление среднего значения
```erlang
Average = (Sum1 + Sum2 + Sum3) / 3,
io:format("Среднее значение: ~p~n", [Average]).
```
- После получения всех результатов, вычисляется среднее значение суммы для всех трех функций, и результат выводится в консоль.

#### Функция `calculate_sum/5`
```erlang
calculate_sum(Start, End, Step, Fun, Parent) ->
    Sum = calculate_sum_loop(Start, End, Step, Fun, 0),
    Parent ! {result, Sum}.
```
- **`calculate_sum/5`** — основная функция для вычисления суммы значений функции в интервале от `Start` до `End` с шагом `Step`.
- Она вызывает рекурсивную функцию `calculate_sum_loop/5` и передает начальный аккумулятор равным 0.
- После вычислений, результат отправляется обратно в родительский процесс через `Parent ! {result, Sum}`.

#### Рекурсивная функция `calculate_sum_loop/5`
```erlang
calculate_sum_loop(X, End, Step, Fun, Acc) when X > End -> 
    Acc;
calculate_sum_loop(X, End, Step, Fun, Acc) -> 
    NewAcc = Acc + Fun(X),
    calculate_sum_loop(X + Step, End, Step, Fun, NewAcc).
```
- **`calculate_sum_loop/5`** — рекурсивная функция, которая вычисляет сумму значений функции.
    - Если текущая позиция X превышает End, возвращает накопленный результат.
    - В противном случае добавляет значение функции к аккумулятору и рекурсивно вызывает себя с увеличенным значением X на `Step`.

#### Типы данных:
- Все входные параметры (Start, End, Step) — числа с плавающей точкой (тип `float`).
- `Fun` — это анонимная функция, которая применяется к каждому значению X.
- `Acc` — аккумулятор, который хранит сумму вычисленных значений функции.
