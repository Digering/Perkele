Вот детализированные комментарии по коду модуля `fibonacci_server`:

```erlang
-module(fibonacci_server).  %% Объявление модуля с именем fibonacci_server
-behaviour(gen_server).      %% Указывает, что этот модуль является сервером, реализующим поведение gen_server

%% API
-export([start_link/0, get/0, reset/0]).  %% Экспортируем три функции: start_link, get, и reset

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]). %% Экспортируем стандартные колбэки для работы с gen_server

%% Starts the Fibonacci server
start_link() -> 
    %% Функция запускает gen_server, привязывая его к локальному имени "fibonacci_server"
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []). 
    %% gen_server:start_link/4 запускает сервер с аргументами:
    %% - {local, ?MODULE}: локальное имя процесса gen_server (имя будет 'fibonacci_server')
    %% - ?MODULE: это просто имя модуля, т.е. 'fibonacci_server'
    %% - []: начальный список аргументов для колбэка init/1, в данном случае пустой список
    %% - []: список опций для запуска процесса, здесь это пустой список
    %% Функция возвращает pid процесса и состояние, если запуск успешен

%% API Functions
get() -> 
    %% Функция для получения следующего числа Фибоначчи
    gen_server:call(?MODULE, get). 
    %% gen_server:call/2 вызывает синхронный запрос к gen_server:
    %% - ?MODULE: имя модуля (fibonacci_server)
    %% - get: запрос, который сервер должен обработать в handle_call/3
    %% Эта функция блокирует выполнение до получения ответа от сервера
    %% Возвращаемое значение — это результат обработки запроса в колбэке handle_call

reset() -> 
    %% Функция для сброса состояния до начальных значений
    gen_server:cast(?MODULE, reset).
    %% gen_server:cast/2 вызывает асинхронный запрос (без ожидания ответа):
    %% - ?MODULE: имя модуля (fibonacci_server)
    %% - reset: команда, которую сервер должен обработать в handle_cast/2
    %% Это приводит к изменению состояния в сервере, но не блокирует выполнение
    %% Ответ от сервера не ожидается, результат не возвращается

%% gen_server callbacks

init([]) -> 
    %% Функция инициализации, вызывается при старте сервера
    %% Аргумент [] - это начальный список аргументов, переданных в gen_server:start_link
    %% В данном случае список пуст, то есть в состоянии сервера изначально два числа Фибоначчи
    {ok, {0, 1}}. 
    %% Возвращаем кортеж {ok, {0, 1}}, где {0, 1} — это начальное состояние
    %% Состояние сервера — это пара чисел Фибоначчи, где 0 — это F(n-2), а 1 — это F(n-1)

handle_call(get, _From, {F0, F1}) -> 
    %% Функция обработки синхронных запросов от клиентов
    %% Аргументы:
    %% - get: запрос клиента
    %% - _From: информация о вызывающем процессе, здесь она не используется, поэтому _From
    %% - {F0, F1}: текущее состояние сервера (F0 = F(n-2), F1 = F(n-1))
    
    Next = F0 + F1, 
    %% Рассчитываем следующее число Фибоначчи как сумму двух предыдущих чисел F0 и F1
    
    {reply, F1, {F1, Next}}.
    %% Возвращаем кортеж:
    %% - reply: это результат ответа клиенту
    %% - F1: это текущее число Фибоначчи (предыдущее число)
    %% - {F1, Next}: обновленное состояние сервера, где F1 становится F(n-2), а Next становится F(n-1)

handle_cast(reset, _State) -> 
    %% Функция обработки асинхронных запросов от клиентов
    %% Аргументы:
    %% - reset: запрос клиента
    %% - _State: текущее состояние, но оно не используется в этом случае, поэтому _State
    
    {noreply, {0, 1}}. 
    %% Возвращаем кортеж {noreply, {0, 1}}, где:
    %% - noreply означает, что сервер не возвращает никакого ответа
    %% - {0, 1} — новое состояние сервера, сбрасываем его на начальные значения (0 и 1)

handle_info(_Msg, State) -> 
    %% Функция обработки неожиданных сообщений
    %% В нашем случае неожиданных сообщений не предполагается, поэтому просто игнорируем их
    %% Аргументы:
    %% - _Msg: сообщение, которое мы игнорируем
    %% - State: текущее состояние сервера
    
    {noreply, State}. 
    %% Возвращаем текущее состояние сервера без изменений, так как не ожидается обработки сообщений

terminate(_Reason, _State) -> 
    %% Функция завершения работы сервера
    %% Этот колбэк вызывается, когда сервер завершает свою работу
    %% Аргументы:
    %% - _Reason: причина завершения работы, которая не используется
    %% - _State: текущее состояние, которое также не используется в данной реализации
    
    ok.
    %% Возвращаем ok, так как никакой очистки не требуется

code_change(_OldVsn, State, _Extra) -> 
    %% Функция для обработки изменения кода (при обновлении версии кода)
    %% Этот колбэк используется для корректного обновления состояния в процессе изменений версии
    
    {ok, State}.
    %% Возвращаем кортеж {ok, State}, где состояние остается неизменным, так как не требуется никаких изменений
```

### Объяснение

- **start_link/0**: Эта функция запускает сервер, и она возвращает `pid` процесса сервера и его начальное состояние.
- **get/0**: Эта функция выполняет синхронный запрос к серверу для получения следующего числа Фибоначчи.
- **reset/0**: Эта функция отправляет асинхронный запрос на сброс состояния сервера до начальных значений.
- **init/1**: Это колбэк, который вызывается при инициализации сервера, устанавливает начальное состояние (первоначальные числа Фибоначчи).
- **handle_call/3**: Обрабатывает синхронные запросы (например, `get`), возвращает текущее число Фибоначчи и обновляет состояние.
- **handle_cast/2**: Обрабатывает асинхронные запросы (например, `reset`), сбрасывает состояние сервера.
- **handle_info/2**: Обрабатывает неожиданные сообщения (в данном случае не используется).
- **terminate/2**: Колбэк для завершения работы сервера.
- **code_change/3**: Колбэк для обработки обновлений кода.

Сервер хранит пару чисел Фибоначчи в своем состоянии и обрабатывает запросы для получения следующего числа или сброса состояния.