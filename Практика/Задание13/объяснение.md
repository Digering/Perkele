Вот подробные комментарии по коду на языке Erlang, который вычисляет суммы значений функций в параллельных потоках:

```erlang
-module(parallel_sum).
-export([start/0, calculate_sum/4]).

% Основная функция start, которая запускает весь процесс
start() ->
    % Определяем параметры для вычислений:
    Start = 0.0,  % Начало интервала (тип данных: float)
    End = 3.14,   % Конец интервала (тип данных: float)
    Step = 0.0000001, % Шаг (тип данных: float)

    % Первая группа потоков: запускаем процессы для двух вычислений
    % Pid1 и Pid2 - это идентификаторы процессов, которые будут вычислять сумму для различных функций
    Pid1 = spawn(parallel_sum, calculate_sum, [Start, End, Step, fun (X) -> math:cos(X) + 45 * X * X end]),
    Pid2 = spawn(parallel_sum, calculate_sum, [Start, End, Step, fun (X) -> 1 / (X + 1) end]),

    % Получаем результаты первой группы потоков
    % Здесь receive_result - это функция, которая ожидает получения результата от процесса
    {ok, Result1} = receive_result(Pid1), % Результат для функции cos(x) + 45x^2
    {ok, Result2} = receive_result(Pid2), % Результат для функции 1/(x+1)

    % Вторая группа потоков: запускаем процессы для еще двух функций
    Pid3 = spawn(parallel_sum, calculate_sum, [Start, End, Step, fun (X) -> 34 * X + 0.098 end]),
    Pid4 = spawn(parallel_sum, calculate_sum, [Start, End, Step, fun (X) -> 17 * X + 9.8 end]),

    % Получаем результаты второй группы потоков
    {ok, Result3} = receive_result(Pid3), % Результат для функции 34x + 0.098
    {ok, Result4} = receive_result(Pid4), % Результат для функции 17x + 9.8

    % После того как все результаты получены, вычисляем среднее значение
    Average = (Result1 + Result2 + Result3 + Result4) / 4,

    % Выводим результаты
    % io:format используется для форматированного вывода
    io:format("Sum 1 (cos(x) + 45x^2): ~p~n", [Result1]),
    io:format("Sum 2 (1/(x+1)): ~p~n", [Result2]),
    io:format("Sum 3 (34x + 0.098): ~p~n", [Result3]),
    io:format("Sum 4 (17x + 9.8): ~p~n", [Result4]),
    io:format("Average of all sums: ~p~n", [Average]),

    % Возвращаем ok, чтобы сигнализировать об успешном завершении
    ok.

% Функция calculate_sum для вычисления суммы значений функции на заданном интервале
calculate_sum(Start, End, Step, Func) ->
    % Вызов рекурсивной функции calculate_loop для суммирования значений
    % self() - возвращает идентификатор текущего процесса, который будет использоваться для отправки результата обратно
    Sum = calculate_loop(Start, End, Step, Func, 0.0),
    self() ! {ok, Sum}. % Отправляем результат назад в процесс, вызвавший эту функцию.

% Рекурсивная функция для суммирования значений функции на интервале
% calculate_loop принимает:
% - Current: текущая точка интервала
% - End: конец интервала
% - Step: шаг
% - Func: функция, которую мы применяем к каждой точке
% - Acc: аккумулятор, который хранит текущую сумму
calculate_loop(Current, End, Step, Func, Acc) when Current > End -> 
    % Если текущая точка превышает конец интервала, возвращаем накопленную сумму
    Acc;
calculate_loop(Current, End, Step, Func, Acc) ->
    % В другом случае добавляем значение функции в аккумулятор и продолжаем рекурсию
    NewAcc = Acc + Func(Current), % Функция Func применяется к текущей точке
    calculate_loop(Current + Step, End, Step, Func, NewAcc). % Переходим к следующей точке

% Функция receive_result для получения результатов от процесса
% Этот код будет ожидать результат в формате {ok, Result} или тайм-аут через 5000 миллисекунд
receive_result(Pid) ->
    receive
        {ok, Result} -> {ok, Result} % Если процесс отправил результат, возвращаем его
    after 5000 -> % Если прошло 5 секунд без ответа, возвращаем ошибку тайм-аута
        {error, timeout}
    end.
```

### Объяснение по кодам:

1. **start/0** — это основная функция, которая инициирует выполнение всего процесса. Она:
    - Определяет начальные параметры (интервал и шаг),
    - Запускает два потока (с помощью `spawn`), которые вычисляют суммы для разных функций,
    - Ожидает результаты от этих потоков с помощью функции `receive_result`,
    - После получения результатов запускает еще два потока для других функций,
    - После получения всех результатов вычисляет среднее значение этих сумм и выводит их с помощью `io:format`.

2. **calculate_sum/4** — эта функция запускает рекурсивную функцию для вычисления суммы значений функции по интервалу от Start до End с заданным шагом Step:
    - Используется аккумулятор для суммирования значений функции,
    - Результат отправляется обратно в основной процесс с помощью `self() ! {ok, Sum}`.

3. **calculate_loop/5** — рекурсивная функция для вычисления суммы значений функции. В каждом вызове:
    - Функция применяет переданную функцию `Func` к текущей точке интервала,
    - Накопленный результат передается в новый рекурсивный вызов,
    - Когда текущая точка интервала превышает конец, возвращается накопленный результат.

4. **receive_result/1** — функция для получения результата от процесса. Она ожидает получения сообщения `{ok, Result}` или тайм-аут через 5 секунд.

### Детали типов данных:

- **Start, End, Step** — все это числа с плавающей запятой типа `float`. Они задают диапазон значений для интегрируемой функции.
- **Pid1, Pid2, Pid3, Pid4** — это идентификаторы процессов (тип данных: pid), которые были созданы с помощью `spawn`. Эти процессы выполняют вычисления в параллельном режиме.
- **Result1, Result2, Result3, Result4** — результаты вычислений в каждом процессе, представляют собой тип данных `float`, так как они содержат суммы значений для каждой функции.
- **Average** — это среднее значение всех результатов, тип данных `float`.
- **Func** — это функциональный аргумент, передаваемый в функции. Он имеет тип `fun`, и определяет математическое выражение, которое должно быть вычислено для каждой точки интервала.

### Ошибки и тайм-ауты:

- В случае тайм-аута (если процесс не отправит результат в течение 5 секунд), функция `receive_result` возвращает `{error, timeout}`.