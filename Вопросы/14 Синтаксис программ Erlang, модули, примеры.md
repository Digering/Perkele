В языке программирования Erlang синтаксис программ ориентирован на функциональное программирование. Программы пишутся в виде модулей, которые содержат функции для выполнения различных задач. Рассмотрим основные элементы синтаксиса, структуру модулей и примеры программ на Erlang.

### 1. **Модули в Erlang**

Программа на Erlang обычно состоит из одного или нескольких **модулей**, каждый из которых имеет имя и содержит функции. Модули в Erlang определяются с помощью директивы `-module`, и все функции модуля должны быть экспортированы с помощью директивы `-export`.

#### Структура модуля:
```erlang
-module(module_name).
-exports([function1/arity, function2/arity, ...]).

% Определение функций
function1(Arg1, Arg2) ->
    % тело функции
    Result.
```

- `-module(module_name)` — директива для указания имени модуля.
- `-export([function1/arity, function2/arity])` — директива для указания функций, которые будут доступны для вызова извне. Здесь `arity` — это количество аргументов у функции.

#### Пример:
```erlang
-module(greetings).
-exports([hello/1, goodbye/1]).

hello(Name) ->
    io:format("Hello, ~s!~n", [Name]).

goodbye(Name) ->
    io:format("Goodbye, ~s!~n", [Name]).
```

Здесь:
- Модуль `greetings` экспортирует две функции: `hello/1` и `goodbye/1`. Обе функции принимают один аргумент `Name` и выводят на экран соответствующее сообщение.

### 2. **Определение функций**

Функции в Erlang определяются с помощью синтаксиса, аналогичного функциональному программированию. Каждая функция состоит из имени, списка аргументов и тела, в котором выполняются вычисления.

#### Общий синтаксис функции:
```erlang
function_name(Arg1, Arg2, ...) ->
    Expression.
```

#### Пример функции с несколькими выражениями:
```erlang
sum(A, B) ->
    Result = A + B,
    io:format("Sum: ~p~n", [Result]),
    Result.
```
Здесь:
- Функция `sum/2` складывает два числа, выводит результат с помощью `io:format` и возвращает его.

#### **Анонимная функция**
В Erlang анонимная функция (также называемая lambda или fun) — это функция, которая не имеет имени и может быть создана динамически в процессе выполнения программы. Она определяется с помощью ключевого слова fun и используется для краткого описания функциональности.

Пример анонимной функции
```erlang
Копировать код
1> Fun = fun(X) -> X * X end.
#Fun<erl_eval.12.126501267>
2> Fun(5).
25
```
Здесь:
- fun(X) -> X * X end создаёт анонимную функцию, которая принимает один аргумент X и возвращает его квадрат.
- Эта функция присваивается переменной Fun.
- Затем функция вызывается с аргументом 5, и результатом является 25.

### 3. **Условия и ветвления**

В Erlang используются стандартные конструкции для ветвления, такие как `if`, `case`, и `cond`.

#### Пример с `if`:
```erlang
max(A, B) ->
    if
        A > B -> A;
        A < B -> B;
        true -> 'Equal'
    end.
```
Здесь:
- Функция `max/2` сравнивает два числа `A` и `B` и возвращает большее из них или строку `'Equal'`, если они равны.

#### Пример с `case`:
```erlang
describe_number(N) ->
    case N of
        0 -> "Zero";
        1 -> "One";
        _ -> "Other"
    end.
```
Здесь:
- Функция `describe_number/1` использует конструкцию `case` для проверки значения числа `N`.

### 4. **Рекурсия**

Рекурсия является важной частью Erlang. Все вычисления, в том числе и итерации, обычно выполняются с использованием рекурсии, поскольку Erlang не поддерживает явные циклы.

#### Пример рекурсивной функции:
```erlang
factorial(0) -> 1;
factorial(N) when N > 0 -> N * factorial(N - 1).
```
Здесь:
- Функция `factorial/1` вычисляет факториал числа. Она рекурсивно вызывает себя, уменьшая значение `N`, пока не достигнет базового случая (`factorial(0) -> 1`).

### 5. **Списки и работы с ними**

Списки в Erlang являются важным типом данных. Рассмотрим пример функции для вычисления суммы элементов списка.

#### Пример работы со списком:
```erlang
sum_list([]) -> 0;
sum_list([H | T]) -> H + sum_list(T).
```
Здесь:
- Функция `sum_list/1` использует рекурсию для вычисления суммы элементов списка. `H` — это голова списка (первый элемент), а `T` — хвост (оставшиеся элементы списка).

### 6. **Состояния и процессы**

Erlang поддерживает параллелизм, и создание процессов — одна из его ключевых особенностей. Процессы в Erlang создаются с помощью функции `spawn` и могут обмениваться сообщениями с помощью `!` (оператор отправки сообщений).

#### Пример создания процесса:
```erlang
spawn(fun() -> io:format("Hello from a process~n") end).
```

#### Пример простого обмена сообщениями:
```erlang
loop() ->
    receive
        {hello, From} -> io:format("Hello, ~p!~n", [From]), loop();
        {stop} -> io:format("Stopping~n");
        _ -> io:format("Unknown message~n"), loop()
    end.
```
Здесь:
- Процесс будет ждать сообщений в блоке `receive`. Если приходит сообщение `{hello, From}`, он выводит приветствие. Если приходит `{stop}`, процесс завершает свою работу.

### 7. **Ошибки и исключения**

Erlang использует принцип "Let it crash" (пусть всё рушится), что означает, что в случае ошибки процесс просто завершится, а система автоматически восстанавливает его состояние, если это необходимо. Однако, в случае ошибок также используется механизм "catch" для перехвата исключений.

#### Пример перехвата исключений:
```erlang
try_some_operation() ->
    try
        1 / 0  % Ошибка деления на ноль
    catch
        error:badarith -> io:format("Caught a division by zero~n")
    end.
```

### Пример программы на Erlang

Рассмотрим пример небольшой программы, которая определяет факториал числа и использует процессы для вычислений.

```erlang
-module(factorial).
-exports([calculate/1, calculate_in_process/1]).

calculate(N) when N >= 0 -> factorial(N).

factorial(0) -> 1;
factorial(N) -> N * factorial(N - 1).

calculate_in_process(N) ->
    Pid = spawn(fun() -> calc_factorial(N) end),
    Pid.

calc_factorial(0) -> io:format("Factorial is 1~n");
calc_factorial(N) when N > 0 ->
    io:format("Factorial of ~p is ~p~n", [N, factorial(N)]).
```

Здесь:
- Модуль `factorial` экспортирует две функции: `calculate/1` для вычисления факториала с помощью рекурсии и `calculate_in_process/1`, которая создаёт процесс для вычисления факториала и выводит результат в консоль.

### Заключение

Erlang использует простой, но мощный синтаксис для создания распределённых и отказоустойчивых приложений. Программы на Erlang обычно организованы в виде модулей, содержащих функции с рекурсией, обработку ошибок и параллелизм через процессы и обмен сообщениями. С помощью такого подхода можно строить высоконагруженные системы, которые легко масштабируются и восстанавливаются от сбоев.
