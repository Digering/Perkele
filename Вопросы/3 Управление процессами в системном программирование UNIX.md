### Управление процессами в системном программировании UNIX

Процессы в UNIX являются ключевой концепцией операционной системы. UNIX предоставляет множество средств для управления процессами, их создания, завершения и взаимодействия. Рассмотрим основные аспекты управления процессами.

---

### Основные понятия

1. **Процесс**:
   - Это выполняемая программа вместе с данными, состоянием и ресурсами.
   - Уникально идентифицируется через **PID** (идентификатор процесса).

2. **Родительский и дочерний процессы**:
   - Каждый процесс имеет родительский процесс, кроме процесса с PID = 1 (`init` или `systemd`), который создается при загрузке системы.
   - Дочерние процессы создаются родительским процессом с помощью системного вызова `fork`.

3. **Состояния процесса**:
   - **Running** (выполняется): процесс активен.
   - **Sleeping** (ожидание): процесс ждет завершения операции ввода-вывода.
   - **Stopped** (остановлен): процесс приостановлен пользователем или сигналом.
   - **Zombie** (зомби): процесс завершен, но информация о нем не удалена, пока родительский процесс не вызовет `wait`.

---

### Системные вызовы для управления процессами

#### 1. **Создание процессов**:
- **`fork()`**:
  - Создает новый процесс (копию текущего).
  - Возвращает:
    - 0 в дочернем процессе.
    - PID дочернего процесса в родительском процессе.
  - Новый процесс (дочерний) имеет отдельное пространство памяти.

Пример:
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Код дочернего процесса
        printf("This is the child process, PID: %d\n", getpid());
    } else if (pid > 0) {
        // Код родительского процесса
        printf("This is the parent process, PID: %d\n", getpid());
    } else {
        // Ошибка при вызове fork
        perror("fork failed");
    }

    return 0;
}
```

---

#### 2. **Завершение процесса**:
- **`exit()`**:
  - Завершает выполнение процесса, возвращая код завершения.
  - Пример: `exit(0);`

- **`_exit()`**:
  - Похожа на `exit`, но не вызывает функции очистки (например, `atexit`).

- **`abort()`**:
  - Немедленно завершает процесс с сигналом `SIGABRT`.

---

#### 3. **Ожидание завершения дочернего процесса**:
- **`wait()`** и **`waitpid()`**:
  - Родительский процесс может ожидать завершения дочернего процесса и получить его код завершения.

Пример:
```c
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Дочерний процесс
        printf("Child process is running\n");
        sleep(2); // Симулируем выполнение
        _exit(0);
    } else {
        // Родительский процесс
        int status;
        wait(&status); // Ожидание завершения дочернего процесса
        printf("Child exited with status %d\n", WEXITSTATUS(status));
    }

    return 0;
}
```

---

#### 4. **Замена текущего процесса**:
- **`exec()`**:
  - Заменяет текущий процесс на новый.
  - Системные вызовы семейства `exec`:
    - `execl`, `execv`, `execle`, `execve`, `execlp`, `execvp`.
  - После успешного вызова `exec` текущий код не выполняется.

Пример:
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    char *args[] = {"/bin/ls", "-l", NULL};
    execv("/bin/ls", args); // Выполнить команду ls -l
    perror("exec failed");  // Эта строка выполняется только в случае ошибки
    return 0;
}
```

---

#### 5. **Сигналы для управления процессами**:
- **Сигналы** — это механизм для взаимодействия процессов и ядра.
  - Примеры сигналов:
    - `SIGKILL` — немедленное завершение процесса.
    - `SIGSTOP` — приостановка выполнения.
    - `SIGCONT` — возобновление выполнения.

Пример обработки сигнала:
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigint(int sig) {
    printf("Caught signal %d\n", sig);
}

int main() {
    signal(SIGINT, handle_sigint); // Обработчик сигнала SIGINT
    while (1) {
        printf("Running...\n");
        sleep(1);
    }

    return 0;
}
```

---

#### 6. **Идентификаторы процессов**:
- **`getpid()`**:
  - Возвращает PID текущего процесса.
- **`getppid()`**:
  - Возвращает PID родительского процесса.

---

### Параллельное выполнение процессов
- **`fork()` + `exec()`**:
  - Используются для запуска независимых программ.

- **Процесс-сервер**:
  - Родительский процесс остается активным, создавая дочерние процессы для обработки задач.

---

### Взаимодействие процессов
1. **Через файлы**:
   - Процессы могут обмениваться данными через общие файлы.

2. **Через каналы (Pipes)**:
   - Односторонняя связь между процессами.
   - Пример использования:
     ```c
     #include <unistd.h>
     #include <stdio.h>

     int main() {
         int fd[2];
         pipe(fd); // Создаем канал

         if (fork() == 0) {
             close(fd[0]); // Закрываем входной конец
             write(fd[1], "Hello", 5);
             close(fd[1]);
         } else {
             char buffer[10];
             close(fd[1]); // Закрываем выходной конец
             read(fd[0], buffer, 5);
             printf("Received: %s\n", buffer);
             close(fd[0]);
         }

         return 0;
     }
     ```

3. **Через разделяемую память**:
   - Используются механизмы `shmget`, `shmat`, `shmdt`.

4. **Через сокеты**:
   - Для обмена данными между процессами, работающими на разных машинах.

---

### Заключение

UNIX предоставляет мощный и гибкий набор инструментов для управления процессами. Эти механизмы позволяют создавать, завершать, синхронизировать и взаимодействовать с процессами, что делает операционную систему UNIX одной из самых эффективных для многозадачной работы.