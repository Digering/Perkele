### Низкоуровневая синхронизация потоков в Java: `wait()`, `notify()`, `notifyAll()`

В многозадачных и многопоточных приложениях часто возникает потребность в синхронизации работы потоков. В Java существует несколько механизмов синхронизации, которые позволяют управлять доступом потоков к общим ресурсам, предотвращать гонки потоков и координировать их выполнение.

Одним из таких механизмов является **низкоуровневая синхронизация** с помощью методов `wait()`, `notify()`, и `notifyAll()`, которые доступны в каждом объекте в Java, поскольку они являются частью класса `Object`. Эти методы позволяют потокам взаимодействовать друг с другом, приостанавливать выполнение и уведомлять другие потоки о событиях.

### 1. **Метод `wait()`**

Метод `wait()` используется для приостановки выполнения текущего потока до тех пор, пока не будет получено уведомление от другого потока. Поток, вызвавший `wait()`, освобождает монитор (или блокирует ресурс), что позволяет другим потокам работать с этим ресурсом.

#### Синтаксис:
```java
synchronized (object) {
    object.wait();  // Текущий поток приостанавливает выполнение
}
```

- Поток, вызвавший `wait()`, должен быть синхронизирован на объекте, иначе будет выброшено исключение `IllegalMonitorStateException`.
- Когда поток вызывает `wait()`, он переходит в состояние "ожидания". Поток будет оставаться в этом состоянии до тех пор, пока не получит сигнал от другого потока.
- Поток, вызвавший `wait()`, также освобождает монитор объекта, на котором вызван метод.

### 2. **Метод `notify()`**

Метод `notify()` уведомляет один из потоков, который ожидает на этом объекте, о том, что он может продолжить выполнение. После того как поток будет уведомлен, он вернется в состояние готовности (ready), но обязательно получит монитор перед тем, как продолжить выполнение.

#### Синтаксис:
```java
synchronized (object) {
    object.notify();  // Оповещает один поток, ожидающий на этом объекте
}
```

- `notify()` будит только один поток, который находится в ожидании на этом объекте. Если несколько потоков ожидают, то выбирается один, который продолжит выполнение.
- Поток, вызвавший `notify()`, должен быть синхронизирован на объекте.

### 3. **Метод `notifyAll()`**

Метод `notifyAll()` уведомляет все потоки, которые находятся в состоянии ожидания на этом объекте. После уведомления все эти потоки будут конкурировать за монитор, и один из них получит его, чтобы продолжить выполнение.

#### Синтаксис:
```java
synchronized (object) {
    object.notifyAll();  // Оповещает все потоки, ожидающие на этом объекте
}
```

- `notifyAll()` полезен, когда необходимо уведомить все потоки, которые ожидают на объекте, например, когда несколько потоков могут продолжить выполнение после того, как завершено какое-то событие или операция.
- В отличие от `notify()`, который будит только один поток, `notifyAll()` пробуждает все потоки, ожидающие на объекте.

### Пример: Использование `wait()`, `notify()`, `notifyAll()`

Для примера можно рассмотреть ситуацию с обменом данных между двумя потоками — производителем и потребителем. Производитель будет добавлять элементы в общий буфер, а потребитель — извлекать их.

```java
class SharedBuffer {
    private int data = -1;
    private final Object lock = new Object();

    // Производитель
    public void produce(int newData) throws InterruptedException {
        synchronized (lock) {
            while (data != -1) {  // Если данные уже есть в буфере, ждем
                lock.wait();
            }
            data = newData;  // Добавляем данные
            System.out.println("Производитель добавил: " + data);
            lock.notify();  // Уведомляем потребителя, что данные появились
        }
    }

    // Потребитель
    public void consume() throws InterruptedException {
        synchronized (lock) {
            while (data == -1) {  // Если данных нет в буфере, ждем
                lock.wait();
            }
            System.out.println("Потребитель забрал: " + data);
            data = -1;  // Очищаем буфер
            lock.notify();  // Уведомляем производителя, что буфер пуст
        }
    }
}

public class ProducerConsumer {
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer();

        // Поток производителя
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    buffer.produce(i);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Поток потребителя
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    buffer.consume();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();  // Запускаем производителя
        consumer.start();  // Запускаем потребителя
    }
}
```

#### Объяснение примера:
1. **Производитель**: Производит данные и помещает их в общий буфер. Если буфер уже содержит данные (т.е. `data != -1`), то поток вызывает `wait()`, чтобы подождать, пока потребитель заберет данные.
2. **Потребитель**: Потребляет данные из буфера. Если буфер пуст (т.е. `data == -1`), то поток вызывает `wait()`, чтобы подождать, пока производитель добавит новые данные.
3. **Синхронизация**: Методы `produce()` и `consume()` синхронизированы с использованием объекта `lock`, чтобы только один поток мог работать с буфером в данный момент.
4. **Методы `wait()` и `notify()`**:
   - Потоки используют `wait()`, чтобы приостановить выполнение, если определенное условие не выполнено (например, буфер пуст или полон).
   - После выполнения своих действий они вызывают `notify()`, чтобы пробудить другой поток, который ожидает на том же объекте.

### Когда использовать `wait()`, `notify()` и `notifyAll()`?

- **`wait()`**: Когда поток должен ожидать, что другое действие или событие произойдет. Например, поток должен ждать, пока другой поток не произведет необходимые данные.
- **`notify()`**: Когда один поток должен уведомить другой поток, что он может продолжить выполнение. Это нужно использовать, когда достаточно уведомить только один поток.
- **`notifyAll()`**: Когда необходимо уведомить все потоки, ожидающие на объекте, что теперь они могут продолжить выполнение. Используется, например, в случаях, когда несколько потоков должны обработать различные данные после наступления события.

### Заключение

Методы `wait()`, `notify()` и `notifyAll()` обеспечивают механизм низкоуровневой синхронизации в Java, позволяя потокам взаимодействовать между собой и правильно управлять их выполнением. Использование этих методов требует внимательности и аккуратности, чтобы избежать ошибок синхронизации, таких как мертвые блокировки (deadlock) и гонки потоков (race conditions).