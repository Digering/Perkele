### Примитивы синхронизации POSIX: мьютексы и условные переменные

Примитивы синхронизации — это средства, предназначенные для упорядочивания доступа к общим ресурсам, когда несколько потоков могут обращаться к ним одновременно. Это важно для предотвращения состояний гонки, когда одновременно несколько потоков пытаются изменять одни и те же данные. В стандарте POSIX для синхронизации потоков предусмотрены несколько примитивов, включая мьютексы и условные переменные.

#### 1. **Мьютексы (Mutexes)**

Мьютекс (от англ. mutual exclusion) — это примитив синхронизации, который используется для обеспечения исключительного доступа к разделяемым данным. Мьютекс блокирует доступ к ресурсу для всех потоков, кроме того, который захватил мьютекс. Это предотвращает одновременный доступ к данным несколькими потоками, что может привести к ошибкам.

##### Основные операции с мьютексами:
- **pthread_mutex_init** — инициализация мьютекса. Применяется для создания мьютекса, который можно будет использовать в дальнейшем.
- **pthread_mutex_lock** — захват мьютекса. Поток блокирует мьютекс, и если он уже захвачен другим потоком, то поток, вызывающий эту функцию, будет заблокирован до тех пор, пока мьютекс не будет освобожден.
- **pthread_mutex_unlock** — освобождение мьютекса. Поток, который захватил мьютекс, должен вызвать эту функцию, чтобы другой поток мог захватить мьютекс.
- **pthread_mutex_destroy** — удаление мьютекса. Используется для освобождения памяти и других ресурсов, связанных с мьютексом, когда он больше не нужен.

##### Пример:
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* thread_func(void* arg) {
    pthread_mutex_lock(&mutex);
    printf("Thread %ld has locked the mutex.\n", (long)arg);
    // Выполнение операций с общими данными
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t threads[2];

    for (long i = 0; i < 2; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void*)i);
    }

    for (int i = 0; i < 2; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    return 0;
}
```
В этом примере два потока захватывают один и тот же мьютекс перед тем, как выполнить свои операции, и освобождают его после завершения работы. Таким образом, они не могут одновременно работать с данными, что предотвращает состояние гонки.

#### 2. **Условные переменные (Condition Variables)**

Условные переменные — это механизм синхронизации, который позволяет одному потоку ожидать, пока другой поток не выполнит определенные действия, прежде чем продолжить выполнение. Это полезно, например, в случаях, когда один поток должен ждать, пока другой поток завершит операцию.

Условные переменные обычно используются в сочетании с мьютексами. Поток, который ожидает условную переменную, сначала захватывает мьютекс, а затем, если условие не выполнено, вызывает функцию ожидания, которая освобождает мьютекс и ставит поток в состояние ожидания.

##### Основные операции с условными переменными:
- **pthread_cond_init** — инициализация условной переменной.
- **pthread_cond_wait** — ожидание на условной переменной. Поток освобождает захваченный мьютекс и ставится в очередь ожидания до тех пор, пока другой поток не сигнализирует об изменении состояния.
- **pthread_cond_signal** — сигнализирует одному из потоков, ожидающих на условной переменной, чтобы тот продолжил выполнение.
- **pthread_cond_broadcast** — сигнализирует всем потокам, ожидающим на условной переменной, чтобы они продолжили выполнение.
- **pthread_cond_destroy** — удаление условной переменной.

##### Пример:
```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int shared_data = 0;

void* producer(void* arg) {
    pthread_mutex_lock(&mutex);
    shared_data = 1;
    printf("Producer: Shared data set to 1.\n");
    pthread_cond_signal(&cond);  // Сигнализируем потребителю
    pthread_mutex_unlock(&mutex);
    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    while (shared_data == 0) {  // Ожидаем, пока данные не будут изменены
        pthread_cond_wait(&cond, &mutex);  // Освобождаем мьютекс и ожидаем сигнала
    }
    printf("Consumer: Shared data is %d.\n", shared_data);
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t prod, cons;

    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    return 0;
}
```
В этом примере потребитель ожидает, пока производитель не установит значение переменной `shared_data` в 1. Как только производитель сигнализирует о готовности (вызывая `pthread_cond_signal`), потребитель продолжает свою работу.

#### 3. **Особенности работы с мьютексами и условными переменными:**

- **Deadlock (взаимная блокировка):** Ситуация, когда два или более потока блокируют ресурсы таким образом, что никто не может продолжить работу. Это может случиться, если потоки захватывают несколько мьютексов или условных переменных в определенном порядке. Чтобы избежать взаимных блокировок, следует проектировать код так, чтобы все потоки захватывали мьютексы в одном и том же порядке.

- **Race Conditions (состояния гонки):** Если несколько потоков одновременно пытаются изменить данные без должной синхронизации, это может привести к ошибкам. Использование мьютексов позволяет предотвратить такие состояния.

- **Спинлоки:** Иногда потоки могут активно проверять условие, не освобождая мьютекс, что называется спинлоком. Это может быть полезно в некоторых ситуациях, но не рекомендуется везде, так как это приводит к перерасходу процессорных ресурсов.

- **Проблема «пробуждения» в случае нескольких сигналов:** Если несколько потоков ожидают условную переменную и один поток подает сигнал (например, вызывает `pthread_cond_signal`), то только один из ожидающих потоков продолжит выполнение. Чтобы пробудить все потоки, следует использовать `pthread_cond_broadcast`.

### Заключение

Мьютексы и условные переменные — это важнейшие инструменты для синхронизации потоков в многозадачных приложениях. Они помогают избежать состояния гонки, взаимных блокировок и других проблем, связанных с параллельным выполнением потоков. Важно понимать их особенности и правильно применять их для обеспечения безопасного и эффективного выполнения многозадачных программ.