В языке программирования Erlang рекурсия является основным способом обработки данных и выполнения повторяющихся операций, поскольку Erlang не поддерживает циклы как традиционные языки программирования. Вместо циклов в Erlang используется рекурсия для обработки списков, кортежей и других коллекций.

### Рекурсия в Erlang

Рекурсия — это процесс, при котором функция вызывает саму себя для решения подзадачи. В Erlang рекурсия часто используется для обхода коллекций данных, таких как списки, а также для реализации других алгоритмов.

Пример рекурсивной обработки списка: вычисление суммы всех элементов списка.

### Пример 1: Рекурсивная функция для вычисления суммы элементов списка

```erlang
sum([]) -> 0;  % Базовый случай: пустой список
sum([Head | Tail]) -> Head + sum(Tail).  % Рекурсивный случай: сумма первого элемента и рекурсивная сумма оставшихся элементов
```

Здесь:
- Когда список пустой (`[]`), функция возвращает 0, это базовый случай.
- Когда список не пустой, функция извлекает первый элемент списка (Head) и вызывает себя рекурсивно с оставшейся частью списка (Tail), прибавляя текущий элемент к результату.

Пример использования:
```erlang
1> c(sum_list).
{ok,sum_list}
2> sum_list:sum([1, 2, 3, 4, 5]).
15
```

### Пример 2: Рекурсивная функция для поиска максимума в списке

```erlang
max([]) -> undefined;  % Если список пустой, вернуть undefined
max([Head]) -> Head;  % Если в списке только один элемент, это максимальное значение
max([Head | Tail]) ->
    MaxTail = max(Tail),  % Рекурсивный вызов для хвоста списка
    if
        Head > MaxTail -> Head;  % Если текущий элемент больше максимума хвоста, вернуть его
        true -> MaxTail         % Иначе вернуть максимум хвоста
    end.
```

Здесь:
- В случае пустого списка возвращается `undefined` как индикатор отсутствия данных.
- Если в списке только один элемент, он является максимальным.
- Для списка с несколькими элементами мы рекурсивно ищем максимум среди хвоста списка и сравниваем его с текущим элементом (Head).

Пример использования:
```erlang
1> c(max_list).
{ok,max_list}
2> max_list:max([3, 1, 4, 1, 5, 9, 2]).
9
```

### Пример 3: Рекурсивная функция для инвертирования списка

```erlang
reverse([]) -> [];  % Базовый случай: пустой список возвращаем как есть
reverse([Head | Tail]) -> reverse(Tail) ++ [Head].  % Рекурсивный случай: инвертируем хвост и добавляем в конец головы
```

Здесь:
- Когда список пустой, возвращаем пустой список.
- В рекурсивном случае инвертируем хвост списка с помощью рекурсивного вызова и добавляем голову элемента в конец.

Пример использования:
```erlang
1> c(reverse_list).
{ok,reverse_list}
2> reverse_list:reverse([1, 2, 3, 4, 5]).
[5,4,3,2,1]
```

### Пример 4: Рекурсивное удаление элемента из списка

Допустим, мы хотим удалить все вхождения определённого элемента из списка. Вот пример рекурсивной функции для этого:

```erlang
remove(_, []) -> [];  % Если список пустой, возвращаем пустой список
remove(Element, [Element | Tail]) -> remove(Element, Tail);  % Если элемент найден, пропускаем его
remove(Element, [Head | Tail]) -> [Head | remove(Element, Tail)].  % Иначе оставляем элемент и продолжаем
```

Здесь:
- Если список пустой, возвращаем пустой список.
- Если текущий элемент совпадает с элементом, который нужно удалить, просто продолжаем рекурсивный вызов для хвоста.
- Если текущий элемент не совпадает, сохраняем его в новом списке.

Пример использования:
```erlang
1> c(remove_list).
{ok,remove_list}
2> remove_list:remove(3, [1, 2, 3, 4, 3, 5, 3]).
[1,2,4,5]
```

### Важные моменты:
- **Базовый случай**: Это условие, которое прекращает рекурсию. Без базового случая рекурсия будет бесконечной и приведёт к переполнению стека.
- **Рекурсивный случай**: Это условие, при котором функция вызывает саму себя для обработки оставшейся части данных.

### Заключение

Рекурсия — важный инструмент в Erlang, особенно для работы с коллекциями данных, такими как списки. Этот подход позволяет решать задачи обхода, обработки и манипуляции данными без использования традиционных циклов, что очень важно в функциональном программировании.